<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>org.elasticsearch.xpack.sql (elasticsearch-scalar-functions API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="declaration: package: org.elasticsearch.xpack.sql">
<meta name="generator" content="javadoc/PackageWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="package-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li class="nav-bar-cell1-rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<div class="header">
<h1 title="Package" class="title">Package&nbsp;org.elasticsearch.xpack.sql</h1>
</div>
<hr>
<div class="package-signature">package <span class="element-name">org.elasticsearch.xpack.sql</span></div>
<section class="package-description" id="package.description">
<div class="block"><b>X-Pack SQL</b> module is a SQL interface to Elasticsearch. <br>
 In a nutshell, currently, SQL acts as a <i>translator</i>, allowing
 traditional SQL queries to be executed against Elasticsearch indices
 without any modifications. Do note that SQL does <i>not</i> try to hide
 Elasticsearch or abstract it in anyway; rather it maps the given SQL,
 if possible, to one (at the moment) query DSL. Of course, this means
 not all SQL queries are supported.<br>

 <h2>Premise</h2>
 Since Elasticsearch is not a database nor does it supports arbitrary
 <code>JOIN</code>s (a cornerstone of SQL), SQL module is built from the
 ground-up with Elasticsearch in mind first and SQL second. In fact,
 even the grammar introduces Elasticsearch specific components that
 have no concept in ANSI SQL.

 <h2>Architecture</h2>
 SQL module is roughly based on the Volcano project (by Graefe
 <code>&amp;</code> co)
 <a href="http://ieeexplore.ieee.org/document/344061">[1]</a>
 <a href="https://dl.acm.org/citation.cfm?id=627558">[2]</a>
 <a href="https://scholar.google.com/citations?user=pdDeRScAAAAJ">[3]</a>

 which argues for several design principles, from which 2 are relevant
 to this project, namely:

 <dl>
  <dt>Logical and Physical algebra</dt>
  <dd>Use of extensible algebraic and logical set of operators to
  describe the operation to underlying engine. The engine job is to
  map a user query into logical algebra and then translate this into
  physical algebra.</dd>
  <dt>Rules to identify patterns</dt>
  <dd>The use of <i>rules</i> as a way to identify relevant
  <i>pattern</i>s inside the plans that can be worked upon</dd>
 </dl>

 In other words, the use of a logical plan, which represents what the
 user has requested and a physical plan which is what the engine needs
 to execute based on the user request. To manipulate the plans, the
 engine does pattern matching implemented as rules that get applied over
 and over until none matches.
 An example of a rule would be expanding <code>*</code> to actual concrete
 references.

 As a side-note, the Volcano model has proved quite popular being used
 (to different degrees) by the majority of SQL engines out there such
 as Apache Calcite, Apache Impala, Apache Spark and Facebook Presto.

 <h2>Concepts</h2>

 The building operation of the SQL engine is defined by an action,
 namely a rule (defined in <a href="../ql/rule/package-summary.html"><code>rule</code></a>
 package that accepts one <i>immutable</i> tree (defined in
 <a href="../ql/tree/package-summary.html"><code>tree</code></a> package) and transforms
 it to another <i>immutable</i> tree.
 Each rules looks for a certain <i>pattern</i> that it can identify and
 then transform.

 The engine works with 3 main type of trees:

 <dl>
   <dt>Logical plan</dt>
   <dd><i>Logical</i> representation of a user query. Any transformation
   of this plan should result in an <i>equivalent</i> plan - meaning for
   the same input, it will generate the same output.</dd>
   <dt>Physical plan</dt>
   <dd><i>Execution</i> representation of a user query. This plan needs
   to translate to (currently) one query to Elasticsearch. It is likely
   in the future (once we look into supporting <code>JOIN</code>s, different
   strategies for generating a physical plan will be available depending
   on the cost. </dd>
   <dt>Expression tree</dt>
   <dd>Both the logical and physical plan contain an expression trees
   that need to be incorporated into the query. For the most part, most
   of the work inside the engine resolves around expressions.</dd>
 </dl>

 All types of tree inside the engine have the following properties:
 <dl>
   <dt>Immutability</dt>
   <dd>Each node and its properties are immutable. A change in a property
   results in a new node which results in a new tree.</dd>
   <dt>Resolution</dt>
   <dd>Due to the algebraic nature of SQL, each tree has the notion of
   resolution which indicates whether it has been resolved or not. A node
   can be resolved only if it <b>and</b> its children have all been
   resolved.</dd>
   <dt>Traversal</dt>
   <dd>Each tree can be traversed top-to-bottom/pre-order/parents-first or
   bottom-up/post-order/children-first. The difference in the traversal
   depends on the pattern that is being identified.</dd>
 </dl>

 A typical flow inside the engine is the following:

 <ol>
  <li>The engine is given a query</li>
  <li>The query is parsed and transformed into an <i>unresolved</i> AST or
  logical plan</li>
  <li>The logical plan gets analyzed and resolved</li>
  <li>The logical plan gets optimized</li>
  <li>The logical plan gets transformed into a physical plan</li>
  <li>The physical plan gets mapped and then folded into an Elasticsearch
  query</li>
  <li>The Elasticsearch query gets executed</li>
 </ol>

 <h3>Digression - Visitors, pattern matching, <code>instanceof</code> and
 Java 10/11/12</h3>

 To implement the above concepts, several choices have been made in the
 engine (which are not common in the rest of the XPack code base). In
 particular the conventions/signatures of
 <a href="../ql/tree/Node.html" title="class in org.elasticsearch.xpack.ql.tree"><code>tree</code></a>s and usage of
 <code>instanceof</code> inside
 <a href="../ql/rule/Rule.html" title="class in org.elasticsearch.xpack.ql.rule"><code>rule</code></a>s).
 Java doesn't provide any utilities for tree abstractions or pattern
 matching for that matter. Typically for tree traversal one would employ
 the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a>
 pattern however that is not a suitable candidate for SQL because:
 <ul>
 <li>the visitor granularity is a node and patterns are likely to involve
 multiple nodes</li>
 <li>transforming a tree and identifying a pattern requires holding a
 state which means either the tree or the visitor become stateful</li>
 <li>a node can stop traversal (which is not desired)</li>
 <li>it's unwieldy - every node type requires a dedicated <code>visit</code>
 method</li>
 </ul>

 While in Java, there might be hope for
 <a href="http://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html">the future</a>
 Scala has made it a
 <a href="https://docs.scala-lang.org/tour/pattern-matching.html">core feature</a>.
 Its byte-code implementation is less pretty as it relies on
 <code>instanceof</code> checks. Which is how many rules are implemented in
 the SQL engine as well. Where possible though, one can use <i>typed</i>
 traversal by passing a <code>Class</code> token to the lambdas (i.e.
 <a href="../ql/tree/Node.html#transformDown(java.lang.Class,java.util.function.Function)"><code>pre-order transformation</code></a>).

 <h2>Components</h2>

 The SQL engine is made up of the following components:
 <dl>
  <dt><a href="parser/package-summary.html"><code>Parser</code></a> package</dt>
  <dd>Tokenizer and Lexer of the SQL grammar. Translates user query into an
  AST tree (<code>LogicalPlan</code>. Makes sure the user query is <b>syntactically</b>
  valid.</dd>
  <dt><a href="analysis/analyzer/PreAnalyzer.html" title="class in org.elasticsearch.xpack.sql.analysis.analyzer"><code>PreAnalyzer</code></a></dt>
  <dd>Performs basic inspection of the <code>LogicalPlan</code> for gathering critical
  information for the main analysis. This stage is separate from <code>Analysis</code>
  since it performs async/remote calls to the cluster. </dd>
  <dt><a href="analysis/analyzer/Analyzer.html" title="class in org.elasticsearch.xpack.sql.analysis.analyzer"><code>Analyzer</code></a></dt>
  <dd>Performs <code>LogicalPlan</code> analysis, resolution and verification. Makes
  sure the user query is actually valid and <b>semantically</b> valid.</dd>
  <dt><a href="optimizer/Optimizer.html" title="class in org.elasticsearch.xpack.sql.optimizer"><code>Optimizer</code></a></dt>
  <dd>Transforms the <i>resolved</i> <code>LogicalPlan</code> into a <i>semantically</i>
  equivalent tree, meaning for the same input, the same output is produced.</dd>
  <dt><a href="planner/Planner.html" title="class in org.elasticsearch.xpack.sql.planner"><code>Planner</code></a></dt>
  <dd>Performs query planning. The planning is made up of two components:
  <dl>
     <dt><code>Mapper</code></dt>
     <dd>Maps the <code>LogicalPlan</code> to a <code>PhysicalPlan</code></dd>
     <dt><code>Folder</code></dt>
     <dd>Folds or rolls-up the <code>PhysicalPlan</code> into an Elasticsearch
     <a href="plan/physical/EsQueryExec.html" title="class in org.elasticsearch.xpack.sql.plan.physical"><code>executable query</code></a>
     </dd>
  </dl>
  </dd>
  <dt><a href="execution/package-summary.html"><code>Execution</code></a></dt>
  <dd>Actual execution of the query, results retrieval, extractions and translation
  into a <a href="session/RowSet.html" title="interface in org.elasticsearch.xpack.sql.session"><code>tabular</code></a> format.</dd>
 </dl></div>
</section>
<section class="summary">
<ul class="summary-list">
<li>
<div class="caption"><span>Class Summary</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><a href="SqlFeatureSet.html" title="class in org.elasticsearch.xpack.sql">SqlFeatureSet</a></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</li>
<li>
<div class="caption"><span>Exception Summary</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Exception</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><a href="SqlClientException.html" title="class in org.elasticsearch.xpack.sql">SqlClientException</a></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><a href="SqlIllegalArgumentException.html" title="class in org.elasticsearch.xpack.sql">SqlIllegalArgumentException</a></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><a href="SqlServerException.html" title="class in org.elasticsearch.xpack.sql">SqlServerException</a></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</li>
</ul>
</section>
</main>
</div>
</div>
</body>
</html>
